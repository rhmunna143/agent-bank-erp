import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

const COLORS = {
  primary: [0, 0, 0],
  green: [0, 0, 0],
  red: [0, 0, 0],
  blue: [0, 0, 0],
  orange: [0, 0, 0],
  gray: [80, 80, 80],
  darkText: [0, 0, 0],
  lightBorder: [180, 180, 180],
};

// Map unsupported Unicode currency symbols to ASCII-safe alternatives for jsPDF
const SYMBOL_MAP = { '৳': 'Tk ', '₹': 'Rs ', '¥': 'Y ', '€': 'EUR ', '£': 'GBP ' };

function safeSym(symbol) {
  return SYMBOL_MAP[symbol] || symbol;
}

function fmtCur(amt, symbol = 'Tk ') {
  const num = parseFloat(amt);
  if (isNaN(num)) return `${symbol}0.00`;
  return `${symbol}${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
}

function fmtDate(d) {
  if (!d) return '';
  try {
    const dt = new Date(d);
    return dt.toLocaleDateString('en-US', { month: 'short', day: '2-digit', year: 'numeric' })
      + '  ' + dt.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
  } catch {
    return String(d);
  }
}

/**
 * Generate a PDF report and open it in a new tab.
 */
export function generateReportPdf({
  reportData,
  bank,
  currencySymbol,
  reportTypeLabel,
  showTransactions,
  showExpenses,
  actualHandCash,
  generatedBy,
}) {
  const sym = safeSym(currencySymbol || '৳');
  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
  const pageW = doc.internal.pageSize.getWidth();
  const pageH = doc.internal.pageSize.getHeight();
  const margin = 14;
  let y = 14;

  // ── Header ──
  doc.setFontSize(18);
  doc.setTextColor(...COLORS.darkText);
  doc.setFont('helvetica', 'bold');
  doc.text(bank?.name || 'Bank Report', margin, y);
  y += 7;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(...COLORS.gray);
  doc.text(
    `${reportTypeLabel}  |  ${fmtDate(reportData.dateFrom)} - ${fmtDate(reportData.dateTo)}`,
    margin,
    y
  );
  y += 5;
  doc.text(`Generated by: ${generatedBy || 'Unknown'}  |  ${new Date().toLocaleString('en-US', { month: 'short', day: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true })}`, margin, y);
  y += 3;

  // Divider
  doc.setDrawColor(...COLORS.lightBorder);
  doc.setLineWidth(0.5);
  doc.line(margin, y, pageW - margin, y);
  y += 6;

  // ── Summary Cards (table-based to avoid overflow) ──
  const cards = [];

  if (showTransactions) {
    cards.push(
      { label: 'Total Deposits', value: fmtCur(reportData.totalDeposits || 0, sym), sub: `${reportData.depositCount || 0} txns`, color: COLORS.green },
      { label: 'Total Withdrawals', value: fmtCur(reportData.totalWithdrawals || 0, sym), sub: `${reportData.withdrawalCount || 0} txns`, color: COLORS.red },
      { label: 'Total Cash In', value: fmtCur(reportData.totalCashIn || 0, sym), sub: `${reportData.cashInCount || 0} txns`, color: COLORS.blue },
    );
  }
  if (showExpenses) {
    cards.push({ label: 'Total Expenses', value: fmtCur(reportData.totalExpenses || 0, sym), sub: `${reportData.expenseCount || 0} items`, color: COLORS.orange });
  }
  cards.push({ label: 'Hand Cash (System)', value: fmtCur(reportData.handCashBalance || 0, sym), sub: 'ERP Calculated', color: COLORS.primary });

  // Add mother account balance cards
  if (reportData.motherAccountBalances && reportData.motherAccountBalances.length > 0) {
    reportData.motherAccountBalances.forEach((ma) => {
      cards.push({ label: ma.name, value: fmtCur(ma.balance, sym), sub: ma.account_number || 'Mother A/C', color: COLORS.darkText });
    });
    cards.push({ label: 'Total Mother Balance', value: fmtCur(reportData.totalMotherBalance || 0, sym), sub: 'All Accounts', color: COLORS.primary });
  }

  // Total Balance = Mother Balance + Hand Cash
  const totalBalance = (reportData.totalMotherBalance || 0) + (reportData.handCashBalance || 0);
  cards.push({ label: 'Total Balance', value: fmtCur(totalBalance, sym), sub: 'Mother + Hand Cash', color: COLORS.primary });

  // Render cards as autoTable rows of 3 per row for proper wrapping
  const colsPerRow = 3;
  const cardAreaW = pageW - margin * 2;
  const gap = 4;
  const cardW = (cardAreaW - (colsPerRow - 1) * gap) / colsPerRow;
  const cardH = 22;

  for (let row = 0; row < Math.ceil(cards.length / colsPerRow); row++) {
    const rowCards = cards.slice(row * colsPerRow, (row + 1) * colsPerRow);

    rowCards.forEach((card, i) => {
      const x = margin + i * (cardW + gap);

      // Card border
      doc.setDrawColor(...COLORS.lightBorder);
      doc.setLineWidth(0.3);
      doc.roundedRect(x, y, cardW, cardH, 2, 2, 'S');

      // Label
      doc.setFontSize(7);
      doc.setTextColor(...COLORS.gray);
      doc.setFont('helvetica', 'normal');
      doc.text(card.label, x + 3, y + 5.5);

      // Value — auto-shrink font to fit within card width
      let fontSize = 12;
      doc.setFont('helvetica', 'bold');
      while (fontSize > 6) {
        doc.setFontSize(fontSize);
        const tw = doc.getTextWidth(card.value);
        if (tw <= cardW - 6) break;
        fontSize -= 0.5;
      }
      doc.setTextColor(...card.color);
      doc.text(card.value, x + 3, y + 13);

      // Sub
      doc.setFontSize(6.5);
      doc.setTextColor(...COLORS.gray);
      doc.setFont('helvetica', 'normal');
      doc.text(card.sub, x + 3, y + 18.5);
    });

    y += cardH + 3;
  }
  y += 2;

  // ── Actual Hand Cash Verification ──
  doc.setDrawColor(...COLORS.green);
  doc.setLineWidth(0.4);
  doc.roundedRect(margin, y, pageW - margin * 2, 10, 2, 2, 'S');
  doc.setFontSize(9);
  doc.setTextColor(...COLORS.darkText);
  doc.setFont('helvetica', 'normal');
  doc.text(`Actual Hand Cash (Counted): ${fmtCur(actualHandCash, sym)}`, margin + 4, y + 6);
  doc.setTextColor(...COLORS.green);
  doc.setFont('helvetica', 'bold');
  doc.text('Verified [OK]', pageW - margin - 4, y + 6, { align: 'right' });
  y += 15;

  // ── Net Flow ──
  doc.setDrawColor(...COLORS.lightBorder);
  doc.setLineWidth(0.3);
  doc.roundedRect(margin, y, pageW - margin * 2, 14, 2, 2, 'S');
  doc.setFontSize(8);
  doc.setTextColor(...COLORS.gray);
  doc.setFont('helvetica', 'normal');
  doc.text('Net Flow', pageW / 2, y + 4.5, { align: 'center' });
  doc.setFontSize(14);
  doc.setTextColor(...COLORS.darkText);
  doc.setFont('helvetica', 'bold');
  doc.text(fmtCur(reportData.netFlow || 0, sym), pageW / 2, y + 11, { align: 'center' });
  y += 19;

  // ── Transaction Details ──
  if (showTransactions && reportData.transactions?.length > 0) {
    if (y > 240) { doc.addPage(); y = 14; }

    doc.setFontSize(12);
    doc.setTextColor(...COLORS.darkText);
    doc.setFont('helvetica', 'bold');
    doc.text('Transaction Details', margin, y);
    y += 2;

    let totalCredit = 0;
    let totalDebit = 0;
    const txnRows = reportData.transactions.map((txn) => {
      const isCredit = txn.type === 'deposit' || txn.type === 'cash_in';
      const isCashIn = txn.type === 'cash_in';
      const amt = Number(txn.amount || 0);
      if (isCredit) totalCredit += amt; else totalDebit += amt;
      const fundInto = isCashIn
        ? (txn.mother_account_id ? (txn.mother_accounts?.name || 'Mother Account') : txn.profit_account_id ? (txn.profit_accounts?.name || 'Profit Account') : 'Hand Cash')
        : '-';
      return [
        fmtDate(txn.created_at),
        (txn.type || '').replace('_', ' ').replace(/^\w/, (c) => c.toUpperCase()),
        txn.customer_name || '-',
        txn.customer_account || '-',
        txn.mother_accounts?.name || txn.mother_accounts?.account_number || '-',
        fundInto,
        isCashIn && txn.source ? txn.source : '-',
        isCredit ? fmtCur(txn.amount, sym) : '-',
        !isCredit ? fmtCur(txn.amount, sym) : '-',
      ];
    });

    // Add total row
    txnRows.push([
      { content: 'Total', colSpan: 7, styles: { halign: 'right', fontStyle: 'bold' } },
      { content: fmtCur(totalCredit, sym), styles: { halign: 'right', fontStyle: 'bold' } },
      { content: fmtCur(totalDebit, sym), styles: { halign: 'right', fontStyle: 'bold' } },
    ]);

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['Date', 'Type', 'Customer', 'Account No.', 'Mother A/C', 'Fund Into', 'Source', 'Credit', 'Debit']],
      body: txnRows,
      styles: { fontSize: 7, cellPadding: 1.5, overflow: 'ellipsize' },
      headStyles: { fillColor: [230, 230, 230], textColor: [0, 0, 0], fontStyle: 'bold', fontSize: 6.5 },
      columnStyles: {
        0: { cellWidth: 28 },
        1: { cellWidth: 15 },
        3: { cellWidth: 'auto' },
        5: { cellWidth: 20 },
        6: { cellWidth: 18 },
        7: { halign: 'right', cellWidth: 20 },
        8: { halign: 'right', cellWidth: 20 },
      },
      theme: 'plain',
    });
    y = doc.lastAutoTable.finalY + 6;
  }

  // ── Expense Details ──
  if (showExpenses && reportData.expenses?.length > 0) {
    if (y > 240) { doc.addPage(); y = 14; }

    doc.setFontSize(12);
    doc.setTextColor(...COLORS.darkText);
    doc.setFont('helvetica', 'bold');
    doc.text('Expense Details', margin, y);
    y += 2;

    const expRows = reportData.expenses.map((exp) => [
      fmtDate(exp.created_at),
      exp.expense_categories?.name || '-',
      exp.description || '-',
      (exp.deduct_from || '').replace('_', ' ').replace(/^\w/, (c) => c.toUpperCase()),
      exp.mother_accounts?.name || exp.mother_accounts?.account_number || exp.profit_accounts?.name || '-',
      fmtCur(exp.amount, sym),
    ]);

    // Add total expense row
    expRows.push([
      { content: 'Total Expense', colSpan: 5, styles: { halign: 'right', fontStyle: 'bold' } },
      { content: fmtCur(reportData.totalExpenses || 0, sym), styles: { halign: 'right', fontStyle: 'bold' } },
    ]);

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['Date', 'Category', 'Description', 'Deducted From', 'Account', 'Amount']],
      body: expRows,
      styles: { fontSize: 7.5, cellPadding: 2, overflow: 'ellipsize' },
      headStyles: { fillColor: [230, 230, 230], textColor: [0, 0, 0], fontStyle: 'bold', fontSize: 7 },
      columnStyles: {
        0: { cellWidth: 28 },
        5: { halign: 'right', cellWidth: 26 },
      },
      theme: 'plain',
    });
    y = doc.lastAutoTable.finalY + 6;
  }

  // ── Signature Section ──
  // Ensure enough space; if not, add a new page
  if (y > pageH - 50) {
    doc.addPage();
    y = 14;
  }

  y += 10;
  const sigLineW = 60;
  const sigLeftX = margin;
  const sigRightX = pageW - margin - sigLineW;

  doc.setDrawColor(...COLORS.darkText);
  doc.setLineWidth(0.3);

  // Left: Agent/CSO signature
  doc.line(sigLeftX, y, sigLeftX + sigLineW, y);
  doc.setFontSize(8);
  doc.setTextColor(...COLORS.darkText);
  doc.setFont('helvetica', 'normal');
  doc.text('Signature of Agent / CSO', sigLeftX, y + 4);
  doc.setFontSize(7);
  doc.setTextColor(...COLORS.gray);
  doc.text('Name: ____________________________', sigLeftX, y + 9);
  doc.text('Date: ____________________________', sigLeftX, y + 14);

  // Right: Authorized signature
  doc.setDrawColor(...COLORS.darkText);
  doc.line(sigRightX, y, sigRightX + sigLineW, y);
  doc.setFontSize(8);
  doc.setTextColor(...COLORS.darkText);
  doc.setFont('helvetica', 'normal');
  doc.text('Authorized Signature', sigRightX, y + 4);
  doc.setFontSize(7);
  doc.setTextColor(...COLORS.gray);
  doc.text('Name: ____________________________', sigRightX, y + 9);
  doc.text('Date: ____________________________', sigRightX, y + 14);

  // ── Footer on every page ──
  const pageCount = doc.internal.getNumberOfPages();
  for (let p = 1; p <= pageCount; p++) {
    doc.setPage(p);
    const footerY = pageH - 8;
    doc.setFontSize(7);
    doc.setTextColor(...COLORS.gray);
    doc.setFont('helvetica', 'normal');
    doc.text(
      `Generated by ${generatedBy || 'Unknown'}  |  ${bank?.name || 'AgentBank ERP'}  |  Page ${p} of ${pageCount}`,
      pageW / 2,
      footerY,
      { align: 'center' }
    );
    doc.text(
      'Software by: @rhmunna143',
      pageW / 2,
      footerY + 4,
      { align: 'center' }
    );
  }

  // Open in new tab
  const pdfBlob = doc.output('blob');
  const url = URL.createObjectURL(pdfBlob);
  window.open(url, '_blank');
}
